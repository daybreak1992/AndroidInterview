##### JVM，ART，Dalvik

- JVM：Java 虚拟机；类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area；
  - 程序计数器：当前线程所执行的字节码的行号指示器，用于记录下一条要运行的指令，线程私有（如果正在执行的是Native方法，计数器值则为空）
  - 虚拟机栈：对象的引用、方法出口等，线程私有
  - 本地方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有
  - 堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享
  - 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享

![JVM框架](image/JVM框架.png)

![JVM框架(中)](image/JVM框架(中).png)

- Classloader：类加载器

  - 加载class方式
    - 隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM
    - 显式：通过class.forname()动态加载
  - 双亲委派模型（Parent Delegation Model）：类的加载过程采用双亲委托机制，这种机制能更好的保证 Java 平台的安全。该模型要求除了顶层的Bootstrap class loader启动类加载器外，其余的类加载器都应当有自己的`父类加载器`。子类加载器和父类加载器`不是以继承（Inheritance）的关系`来实现，而是通过`组合（Composition）关系`来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）
    - Bootstrap Class Loader：是虚拟机的一部分， 主要加载JVM自身工作需要的类，完全由JVM控制，开发者无法访问.(无法被Java代码引用)；将指定目录下的符合虚拟机规范的类加载到虚拟机内存中，默认是\lib
    - Extension Class Loader：负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用拓展类加载器
    - App Class Loader：由于这个类加载器是getSystemClassLoder()方法的返回值，所以又称系统加载器 ,它负责加载classPath路径上的指定的类库 ,如果程序中没有定义过类加载器，一般作为默认的类加载器

  ![类加载器结构](image/类加载器结构.png)

- Java内存堆与栈的区别

  - 栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
  - 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问
  - 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError
  - 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小，-Xms选项可以设置堆的开始时的大小

- Java四种引用

  - 强引用（StrongReference）：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题
  - 软引用（SoftReference）：如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器
  - 回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中
  - 弱引用（WeakReference）：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中
  - 虚引用（PhantomReference）：虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中

- GC

  - GC标记算法：引用计数法；根搜索算法(可达性算法)

  - GC回收算法

    - 标记-清除法：标记出没有用的对象，然后一个一个回收掉

      缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作

    - 复制算法: 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉

      缺点：将内存缩小为了原来的一半

    - 标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内

      优点：解决了标记- 清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题

    - 分代回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法

- ART：ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快

- Dalvik：它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行，独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭

##### 四大组件

- Activity

  - standard：标准模式；每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶，而不管这个Activity是否已经存在，Activity的启动三回调(*onCreate()->onStart()->onResume()*)都会执行
  - singleTop：栈顶复用模式；这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，所以它的启动三回调就不会执行，同时Activity的`onNewIntent()`方法会被回调，如果Activity已经存在但是不在栈顶，那么作用与*standard模式*一样
  - singleTask：栈内复用模式；创建这样的Activity的时候，系统会先确认它所需任务栈已经创建，否则先创建任务栈.然后放入Activity，如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶，同时Activity的`onNewIntent()`方法会被回调，并且singleTask会清理在当前Activity上面的所有Activity(clear top)
  - singleInstance：加强版的singleTask模式；这种模式的Activity只能单独位于一个任务栈内，由于栈内复用的特性，后续请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了

  ![Activity生命周期](image/Activity生命周期.png)

  ![Fragment生命周期](image/Fragment生命周期.png)

- Service

  ![Service生命周期](image/Service生命周期.jpg)

  - 启动服务

    ![Service-startService()](image/Service-startService().png)

    ![Service-stopService()](image/Service-stopService().png)

  - 绑定服务

    ![Service-bindService()](image/Service-bindService().png)

    ![Service-unbindService()](image/Service-unbindService().png)

  - IntentService

    - 通过HandlerThread 单独开启1个工作线程：IntentService

    - 创建1个内部 Handler ：ServiceHandler

    - 绑定 ServiceHandler 与 IntentService

    - 通过 onStartCommand()传递服务Intent 到ServiceHandler、依次插入Intent到工作队列中 & 逐个发送给 onHandleIntent()

    - 通过onHandleIntent()依次处理所有Intent对象所对应的任务

      ```java
      @Override
      public void onCreate() {
          super.onCreate();
          // 1. 通过实例化andlerThread新建线程 & 启动；故 使用IntentService时，不需额外新建线程
          // HandlerThread继承自Thread，内部封装了 Looper
          HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
          thread.start();
        
          // 2. 获得工作线程的 Looper & 维护自己的工作队列
          mServiceLooper = thread.getLooper();

          // 3. 新建mServiceHandler & 绑定上述获得Looper
          // 新建的Handler 属于工作线程 ->>分析1
          mServiceHandler = new ServiceHandler(mServiceLooper); 
      }

      /** 
       * 分析1：ServiceHandler源码分析
       **/   
      private final class ServiceHandler extends Handler {
               // 构造函数
               public ServiceHandler(Looper looper) {
               super(looper);
             	}

              // IntentService的handleMessage（）把接收的消息交给onHandleIntent()处理
              @Override
               public void handleMessage(Message msg) {
                // onHandleIntent 方法在工作线程中执行
                // onHandleIntent() = 抽象方法，使用时需重写 ->>分析2
                onHandleIntent((Intent)msg.obj);
                // 执行完调用 stopSelf() 结束服务
                stopSelf(msg.arg1);
          	}
      }

      /** 
       * 分析2： onHandleIntent()源码分析
       * onHandleIntent() = 抽象方法，使用时需重写
       **/ 
      @WorkerThread
      protected abstract void onHandleIntent(Intent intent);
      ```

      ![IntentService原理](image/IntentService原理.png)

  - HandlerThread

    - HandlerThread本质上是一个线程类，它继承了Thread

    - HandlerThread有自己的内部Looper对象，可以进行looper循环

    - 通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务

    - 创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象

      ```java
      HandlerThread handlerThread = new HandlerThread("downloadImage");

      //必须先开启线程
      handlerThread.start();

      /**
       * 该callback运行于子线程
       */
      class ChildCallback implements Handler.Callback {
           @Override
           public boolean handleMessage(Message msg) {
           	//在子线程中进行相应的网络请求
              //通知主线程去更新UI
               mUIHandler.sendMessage(msg1);
               return false;
           }
      }

      //子线程Handler
      Handler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback());
      ```

- BroadcastReceiver

  - 注册方式

    - 静态注册

      ```java
      <receiver 
          android:enabled=["true" | "false"]
      //此broadcastReceiver能否接收其他App的发出的广播
      //默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false
          android:exported=["true" | "false"]
          android:icon="drawable resource"
          android:label="string resource"
      //继承BroadcastReceiver子类的类名
          android:name=".mBroadcastReceiver"
      //具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；
          android:permission="string"
      //BroadcastReceiver运行所处的进程
      //默认为app的进程，可以指定独立的进程
      //注：Android四大基本组件都可以通过此属性指定自己的独立进程
          android:process="string" >

      //用于指定此广播接收器将接收的广播类型
      //本示例中给出的是用于接收网络状态改变时发出的广播
       <intent-filter>
      <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
          </intent-filter>
      </receiver>
      ```

      - 动态注册

        ```java
        // 选择在Activity生命周期方法中的onResume()中注册
        // 1. 实例化BroadcastReceiver子类 &  IntentFilter
        mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver();
        IntentFilter intentFilter = new IntentFilter();

        // 2. 设置接收广播的类型
        intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);

        // 3. 动态注册：调用Context的registerReceiver（）方法
        registerReceiver(mBroadcastReceiver, intentFilter);

        // 销毁在onPause()方法中的广播
        unregisterReceiver(mBroadcastReceiver);
        ```

        ​

  ![BroadcastReceiver原理](image/BroadcastReceiver原理.png)

  ![BroadcastReceiver使用流程](image/BroadcastReceiver使用流程.png)
